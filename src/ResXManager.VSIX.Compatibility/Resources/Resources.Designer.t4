<#@ assembly name="System.Core" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<# // You need to reference "Microsoft.VisualStudio.Interop to run it on VS2022: #>
<# // @ assembly name="Microsoft.VisualStudio.Interop" #> 
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Resources" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.ComponentModel.Design" #>
<#@ output extension=".cs" #><#

    var resxItem = GetResxProjectItem();
    var resxPath = resxItem.FileNames[0];
    var localNamespace = GetLocalNamespace(resxItem);
    var className = Path.GetFileNameWithoutExtension(resxPath).Replace(".", "_");

    using (var reader = new ResXResourceReader(resxPath) {UseResXDataNodes = true, BasePath=Path.GetDirectoryName(resxPath)})
    {
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// 
// This template generates PublicResXFileCodeGenerator compatible code plus some
// useful extensions. 
// 
// The original version provided by ResXResourceManager is restricted to resource key names
// that are valid c# identifiers to keep this template simple (KISS!).
// 
// Us it as it is or as a scaffold to generate the code you need.
//
// As long as you have ResXResourceManager running in the background, the generated code 
// will be kept up to date.
//  
//------------------------------------------------------------------------------

namespace <#= localNamespace #> {
    using System;

    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by a text template.
    // To add or remove a member, edit your .ResX file.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ResXResourceManager", "1.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class <#= className #> {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal <#= className #>() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("<#= localNamespace #>.<#= className #>", typeof(<#= className #>).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
<#
        foreach (var node in GetResxNodes(reader))
        {
            if (node.Type == typeof (string))
            {
#>

        /// <summary>
        ///   Looks up a localized string similar to "<#= XmlEscape(node.Value, 50) #>"
        /// </summary>
<# InsertRemarks(node.Comment); #>
        public static string <#= node.Key #> {
            get {
                return ResourceManager.GetString("<#= node.Key #>", resourceCulture) ?? string.Empty;
            }
        }
<#
            }
            else
            {
#>

        /// <summary>
        ///   Looks up a localized resource of type <#= node.Type.FullName #>.
        /// </summary>
<# InsertRemarks(node.Comment); #>
        public static <#= node.Type.FullName #> <#= node.Key #> {
            get {
                object obj = ResourceManager.GetObject("<#= node.Key #>", resourceCulture);
                return ((<#= node.Type.FullName #>)(obj));
            }
        }
<#
            }
        }
#>
    }

    /// <summary>
    /// Keys of all available strings in the applications resx-resources.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("ResXResourceManager", "1.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGenerated]
    public enum StringResourceKey
    {
<#
    foreach (var node in GetResxNodes(reader).Where(node => node.Type == typeof (string)))
    {
#>
        /// <summary>
        ///   Looks up a localized string similar to <#= XmlEscape(node.Value, 50) #>.
        /// </summary>
<# InsertRemarks(node.Comment); #>
        <#= node.Key #>,
<#
    }
#>
    }
<#
    }
#>

    /// <summary>
    /// Specifies a localized description for an object.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("ResXResourceManager", "1.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [AttributeUsage(AttributeTargets.All, AllowMultiple=false)]
    public sealed class LocalizedDescriptionAttribute : System.ComponentModel.DescriptionAttribute
    {
        private readonly string _resourceKey;

        /// <summary>
        /// Initializes a new instance of the <see cref="LocalizedDescriptionAttribute"/> class.
        /// </summary>
        /// <param name="resourceKey">The resource key of the associated resource.</param>
        public LocalizedDescriptionAttribute(StringResourceKey resourceKey)
        {
            _resourceKey = resourceKey.ToString();
        }

        /// <summary>
        /// Gets the localized description from the resource id stored in this attribute.
        /// </summary>
        public override string Description
        {
            get
            {
                return <#= className #>.ResourceManager.GetString(_resourceKey);
            }
        }
    }

    /// <summary>
    /// Specifies a localized display name for an object.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("ResXResourceManager", "1.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [AttributeUsage(AttributeTargets.All, AllowMultiple=false)]
    public sealed class LocalizedDisplayNameAttribute : System.ComponentModel.DisplayNameAttribute
    {
        private readonly string _resourceKey;

        /// <summary>
        /// Initializes a new instance of the <see cref="LocalizedDisplayNameAttribute"/> class.
        /// </summary>
        /// <param name="resourceKey">The resource key of the associated resource.</param>
        public LocalizedDisplayNameAttribute(StringResourceKey resourceKey)
        {
            _resourceKey = resourceKey.ToString();
        }

        /// <summary>
        /// Gets the localized display name from the resource id stored in this attribute.
        /// </summary>
        public override string DisplayName
        {
            get
            {
                return <#= className #>.ResourceManager.GetString(_resourceKey);
            }
        }
    }

    /// <summary>
    /// Specifies a localized category for an object.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("ResXResourceManager", "1.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [AttributeUsage(AttributeTargets.All, AllowMultiple=false)]
    public sealed class LocalizedCategoryAttribute : System.ComponentModel.CategoryAttribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LocalizedCategoryAttribute"/> class.
        /// </summary>
        /// <param name="resourceKey">The resource key of the associated resource.</param>
        public LocalizedCategoryAttribute(StringResourceKey resourceKey)
            : base(resourceKey.ToString())
        {
        }

        /// <summary>
        /// Gets the localized category name from the resource id stored in this attribute.
        /// </summary>
        protected override string GetLocalizedString(string value)
        {
            return <#= className #>.ResourceManager.GetString(value);
        }
    }
<#
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* <-- Add a second slash at the begining of this line to enable the LocalizedTextAttribute. 
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // The LocalizedTextAttribute requires the the TomsToolbox.Essentials NuGet package.
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    {
#>

    /// <summary>
    /// Specifies a localized display name for an object.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("ResXResourceManager", "1.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
    public sealed class LocalizedTextAttribute : global::TomsToolbox.Essentials.TextAttribute
    {
        // This code is generated by Resources.Designer.t4
        // If you get compile errors because you don't use the TomsToolbox.Essentials NuGet package, 
        // either remove this part in the Resources.Designer.t4 file, or add a reference to the TomsToolbox.Essentials NuGet package.
        // Just search for this text and follow the instructions above.

        private readonly string _resourceKey;

        /// <summary>
        /// Initializes a new instance of the <see cref="LocalizedTextAttribute"/> class.
        /// </summary>
        /// <param name="key">Any user defined key to specify the usage of this text.</param>
        /// <param name="resourceKey">The resource key of the associated resource.</param>
        public LocalizedTextAttribute(object key, StringResourceKey resourceKey)
            : base(key)
        {
            _resourceKey = resourceKey.ToString();
        }

        /// <summary>
        /// Gets the localized text from the resource id stored in this attribute.
        /// </summary>
        public override string Text
        {
            get
            {
                return <#= className #>.ResourceManager.GetString(_resourceKey);
            }
        }
    }
<#
    }
    //*/
#>

<#
    {
        var validatorNameSpacePrefix = "System.ComponentModel.DataAnnotations.";

        var validators = new []
        {
            new { Name = "DataTypeAttribute", Constructors = new []
            {
                new { Parameters = new[] { new { DataType="System.ComponentModel.DataAnnotations.DataType", Name="dataType" }}},
                new { Parameters = new[] { new { DataType="string", Name="customDataType" }}},
            }},
            new { Name = "RangeAttribute", Constructors = new[]
            {
                new { Parameters = new[] { new { DataType="int", Name="minimum"}, new { DataType="int", Name="maximum" }}},
                new { Parameters = new[] { new { DataType="double", Name="minimum"}, new { DataType="double", Name="maximum" }}},
                new { Parameters = new[] { new { DataType="Type", Name="type"}, new { DataType="string", Name="minimum"}, new { DataType="string", Name="maximum" }}}
            }},
            new { Name = "RegularExpressionAttribute", Constructors = new[]
            {
                new { Parameters = new[] { new { DataType="string", Name="pattern"}}}
            }},
            new { Name = "RequiredAttribute", Constructors = new[]
            {
                new { Parameters = new[] { new { DataType=(string)null, Name=(string)null }}}   
            }},
            new { Name = "StringLengthAttribute", Constructors = new[]
            {
                new { Parameters = new[] { new { DataType="int", Name = "maximumLength"}}}
            }}
        };

        foreach (var validator in validators)
        {
#>
    /// <summary>
    /// A localizable version of the <see cref="<#= validatorNameSpacePrefix #><#= validator.Name #>"/> class.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("ResXResourceManager", "1.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property, AllowMultiple = false)]
    public class <#= validator.Name #> : <#= validatorNameSpacePrefix #><#= validator.Name #>
    {
        private StringResourceKey _resourceKey;

<# foreach (var constructor in validator.Constructors) { #>
        /// <summary>
        /// Initializes a new instance of the <see cref="<#= validator.Name #>"/> class.
        /// </summary>
<#
    var effectiveParameters = constructor.Parameters.Where(p => p.DataType != null).ToArray();
    var methodParameters = string.Join(", ", effectiveParameters.Select(p => p.DataType + " " + p.Name));
    var baseParameters = string.Join(", ", effectiveParameters.Select(p => p.Name));
    if (effectiveParameters.Any())
        methodParameters = ", " + methodParameters;
#>
        public <#= validator.Name #>(StringResourceKey resourceKey<#= methodParameters  #>)
            : base(<#= baseParameters #>)
        {
            ResourceKey = resourceKey;
        }

<# } #>
        /// <summary>
        /// Gets or sets the resource key.
        /// </summary>
        public StringResourceKey ResourceKey
        {
            get
            {
                return _resourceKey;
            }
            set
            {
                _resourceKey = value;
                ErrorMessageResourceType = typeof(<#= className #>);
                ErrorMessageResourceName = value.ToString();
            }
        }
    }
    
<#
        }
    }
#>

}
<#+
    ProjectItem GetResxProjectItem()
    {
        var serviceProvider = (IServiceProvider)Host;
        var dte = (DTE2)serviceProvider.GetService(typeof(DTE));
        var ttItem = dte.Solution.FindProjectItem(Host.TemplateFile);
        return (ProjectItem)ttItem.Collection.Parent;        
    }

    string GetLocalNamespace(ProjectItem resxItem)
    {
        var resxPath = resxItem.FileNames[0];
        var resxFolder = Path.GetDirectoryName(resxPath);
        var project = resxItem.ContainingProject;
        var projectFolder = Path.GetDirectoryName(project.FullName);
        var rootNamespace = project.Properties.Item("RootNamespace").Value.ToString();

        var localNamespace = rootNamespace;
        if (resxFolder.StartsWith(projectFolder, StringComparison.OrdinalIgnoreCase))
        {
            localNamespace += resxFolder.Substring(projectFolder.Length).Replace('\\', '.');
        }

        return localNamespace;
    }

    void InsertRemarks(string comment)
    {
        if (string.IsNullOrEmpty(comment)) 
            return;

        WriteLine("        /// <remarks>");
        WriteLine("        /// " + XmlEscape(comment));
        WriteLine("        /// </remarks>");
    }

    struct ResxNode
    {
        public string Key;
        public string Value;
        public string Comment;
        public Type Type;
    }

    IEnumerable<ResxNode> GetResxNodes(ResXResourceReader reader)
    {
        return reader.Cast<DictionaryEntry>()
            .Select(item => (ResXDataNode)item.Value)
            .Select(node => new ResxNode
            {
                Key = node.Name,
                Comment = node.Comment,
                Value = node.GetValue((ITypeResolutionService)null) as string,
                Type = Type.GetType(node.GetValueTypeName((ITypeResolutionService)null))
            })
            .OrderBy(node => node.Key);
    }

    public string XmlEscape(string value)
    {
        return value
            .Replace("\n", "&#10;")
            .Replace("\r", "&#13;")
            .Replace(">", "&gt;")
            .Replace("<", "&lt;")
            .Replace("&", "&amp;");
    }

    public string XmlEscape(string value, int maxLen)
    {
        value = XmlEscape(value);
        if (value.Length <= maxLen)
            return value;        
        
        return value.Substring(0, maxLen) + "...";
    }

#>